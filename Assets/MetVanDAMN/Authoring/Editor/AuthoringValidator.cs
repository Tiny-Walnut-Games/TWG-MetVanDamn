using UnityEngine;
using UnityEngine.Tilemaps;
using UnityEditor;
using Unity.Collections;
using Unity.Entities;
using TinyWalnutGames.MetVD.Core;
using System.Collections.Generic;
using System.Linq;

namespace TinyWalnutGames.MetVD.Authoring.Editor
{
    public static class AuthoringValidator
    {
        [System.Serializable] public class ValidationReport { public List<ValidationIssue> issues=new(); public int errorCount; public int warningCount; public bool hasErrors=>errorCount>0; public bool hasWarnings=>warningCount>0; }
        [System.Serializable] public class ValidationIssue { public ValidationSeverity severity; public string category; public string message; public Object targetObject; public Vector3 worldPosition; public ValidationIssue(ValidationSeverity s,string c,string m,Object target=null,Vector3 pos=default){severity=s;category=c;message=m;targetObject=target;worldPosition=pos;} }
        public enum ValidationSeverity { Error, Warning, Info }

        [MenuItem("Tools/MetVanDAMN/Validate Scene Authoring")] public static void ValidateSceneAuthoring(){ var report=ValidateScene(); DisplayValidationReport(report); }
        public static ValidationReport ValidateScene(){ var report=new ValidationReport(); var districts=Object.FindObjectsByType<DistrictAuthoring>(FindObjectsSortMode.None); var connections=Object.FindObjectsByType<ConnectionAuthoring>(FindObjectsSortMode.None); var biomes=Object.FindObjectsByType<BiomeFieldAuthoring>(FindObjectsSortMode.None); var gates=Object.FindObjectsByType<GateConditionAuthoring>(FindObjectsSortMode.None); ValidateDistricts(districts,report); ValidateConnections(connections,districts,report); ValidateBiomes(biomes,report); ValidateGateConditions(gates,connections,report); ValidateDistrictConnections(districts,connections,report); SuggestAutoFixes(districts,biomes,report); ValidateNavigationConnectivity(report); report.errorCount=report.issues.Count(i=>i.severity==ValidationSeverity.Error); report.warningCount=report.issues.Count(i=>i.severity==ValidationSeverity.Warning); return report; }

        private static void ValidateDistricts(DistrictAuthoring[] districts, ValidationReport report){ var ids=new HashSet<uint>(); var dup=new HashSet<uint>(); foreach(var d in districts){ if(d==null) continue; uint id=d.nodeId; if(ids.Contains(id)) { dup.Add(id); report.issues.Add(new ValidationIssue(ValidationSeverity.Error,"Duplicate NodeId",$"District NodeId {id} is used by multiple districts.",d,d.transform.position)); } else ids.Add(id); if(id==0) report.issues.Add(new ValidationIssue(ValidationSeverity.Warning,"Invalid NodeId","District has NodeId 0.",d,d.transform.position)); if(d.targetSectorCount<=0) report.issues.Add(new ValidationIssue(ValidationSeverity.Error,"Invalid Sector Count","District has zero or negative target sector count.",d,d.transform.position)); } foreach(var id in dup){ var conflicts=districts.Where(x=>x!=null && x.nodeId==id).Select(x=>x.name); report.issues.Add(new ValidationIssue(ValidationSeverity.Error,"NodeId Conflict Summary",$"NodeId {id} used by: {string.Join(", ",conflicts)}")); } }

        private static void ValidateConnections(ConnectionAuthoring[] connections, DistrictAuthoring[] districts, ValidationReport report){ var valid=new HashSet<uint>(districts.Where(d=>d!=null).Select(d=>d.nodeId)); foreach(var c in connections){ if(c==null) continue; if(!valid.Contains(c.sourceNode)) report.issues.Add(new ValidationIssue(ValidationSeverity.Error,"Missing Source District",$"Connection references source NodeId {c.sourceNode} but no district exists.",c,c.transform.position)); if(!valid.Contains(c.targetNode)) report.issues.Add(new ValidationIssue(ValidationSeverity.Error,"Missing Target District",$"Connection references target NodeId {c.targetNode} but no district exists.",c,c.transform.position)); if(c.sourceNode==c.targetNode) report.issues.Add(new ValidationIssue(ValidationSeverity.Warning,"Self-Referencing Connection","Connection has same source and target.",c,c.transform.position)); } }

        private static void ValidateGateConditions(GateConditionAuthoring[] gates, ConnectionAuthoring[] connections, ValidationReport report){ var connPairs=new HashSet<(uint,uint)>(connections.Where(c=>c!=null).Select(c=>(c.sourceNode,c.targetNode))); foreach(var g in gates){ if(g==null) continue; if(!connPairs.Contains((g.sourceNode,g.targetNode))) report.issues.Add(new ValidationIssue(ValidationSeverity.Warning,"Orphaned Gate Condition",$"Gate for {g.sourceNode}->{g.targetNode} has no matching connection.",g,g.transform.position)); } }

        private static void ValidateBiomes(BiomeFieldAuthoring[] biomes, ValidationReport report){ foreach(var b in biomes){ if(b==null) continue; if(b.nodeId==0) report.issues.Add(new ValidationIssue(ValidationSeverity.Error,"Invalid Biome Assignment","BiomeField has invalid or missing NodeId.",b,b.transform.position)); if(b.fieldRadius<=0) report.issues.Add(new ValidationIssue(ValidationSeverity.Error,"Invalid Field Radius","BiomeField has invalid field radius.",b,b.transform.position)); } }

        private static void ValidateDistrictConnections(DistrictAuthoring[] districts, ConnectionAuthoring[] connections, ValidationReport report){ var connected=new HashSet<uint>(); foreach(var c in connections.Where(c=>c!=null)){ connected.Add(c.sourceNode); connected.Add(c.targetNode); } foreach(var d in districts.Where(d=>d!=null)){ if(!connected.Contains(d.nodeId)) report.issues.Add(new ValidationIssue(ValidationSeverity.Warning,"Isolated District","District has no connections.",d,d.transform.position)); } }

        private static void SuggestAutoFixes(DistrictAuthoring[] districts, BiomeFieldAuthoring[] biomes, ValidationReport report){ var used=new HashSet<uint>(districts.Where(d=>d!=null && d.nodeId!=0).Select(d=>d.nodeId)); foreach(var b in biomes.Where(b=>b!=null && b.nodeId!=0)) used.Add(b.nodeId); uint next=1; foreach(var d in districts.Where(d=>d!=null && d.nodeId==0)){ while(used.Contains(next)) next++; report.issues.Add(new ValidationIssue(ValidationSeverity.Info,"Auto-Fix Suggestion",$"District '{d.name}' missing NodeId. Suggested: {next}",d,d.transform.position)); used.Add(next); next++; } foreach(var b in biomes.Where(b=>b!=null && b.nodeId==0)){ while(used.Contains(next)) next++; report.issues.Add(new ValidationIssue(ValidationSeverity.Info,"Auto-Fix Suggestion",$"BiomeField '{b.name}' missing NodeId. Suggested: {next}",b,b.transform.position)); used.Add(next); next++; } }

        private static void ValidateNavigationConnectivity(ValidationReport report){ var world=World.DefaultGameObjectInjectionWorld; if(world==null||!world.IsCreated){ report.issues.Add(new ValidationIssue(ValidationSeverity.Warning,"Navigation Validation Skipped","World not available for navigation validation.")); return; } var navReport=NavigationValidationUtility.GenerateValidationReport(world); try { if(navReport.HasUnreachableAreas) report.issues.Add(new ValidationIssue(ValidationSeverity.Warning,"Unreachable Navigation Areas",$"Found {navReport.UnreachableNodeCount} unreachable navigation nodes.")); } finally { navReport.Dispose(); } }

        private static void DisplayValidationReport(ValidationReport report){ string title="MetVanDAMN Authoring Validation Report"; if(report.issues.Count==0){ EditorUtility.DisplayDialog(title,"All authoring components valid!","OK"); return;} var msg=$"Found {report.issues.Count} issues:\n• {report.errorCount} errors\n• {report.warningCount} warnings\n"; int maxShow=5; for(int i=0;i<Mathf.Min(maxShow,report.issues.Count);i++){ var issue=report.issues[i]; string icon=issue.severity==ValidationSeverity.Error?"❌": issue.severity==ValidationSeverity.Warning?"⚠️":"ℹ️"; msg+=$"{icon} {issue.category}: {issue.message}\n"; } if(report.issues.Count>maxShow) msg+=$"... and {report.issues.Count-maxShow} more issues."; EditorUtility.DisplayDialog(title,msg,"OK"); }
    }
}
