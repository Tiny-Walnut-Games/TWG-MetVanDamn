using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Mathematics;
using TinyWalnutGames.MetVD.Core;
using TinyWalnutGames.MetVD.Graph;
using TinyWalnutGames.MetVD.Biome;

namespace TinyWalnutGames.MetVD.Graph
{
    /// <summary>
    /// System that handles the complete procedural bootstrap of the world hierarchy.
    /// Generates Biomes ‚Üí Districts ‚Üí Sectors ‚Üí Rooms from a single bootstrap configuration.
    /// Runs before the existing DistrictLayoutSystem to provide districts to place.
    /// </summary>
    [BurstCompile]
    [UpdateInGroup(typeof(InitializationSystemGroup))]
    [UpdateBefore(typeof(DistrictLayoutSystem))]
    public partial struct WorldBootstrapSystem : ISystem
    {
        private EntityQuery _bootstrapQuery;
        private EntityQuery _inProgressQuery;
        private EntityQuery _completeQuery;

        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            _bootstrapQuery = new EntityQueryBuilder(Allocator.Temp)
                .WithAll<WorldBootstrapConfiguration>()
                .WithNone<WorldBootstrapInProgressTag, WorldBootstrapCompleteTag>()
                .Build(ref state);
                
            _inProgressQuery = new EntityQueryBuilder(Allocator.Temp)
                .WithAll<WorldBootstrapConfiguration, WorldBootstrapInProgressTag>()
                .Build(ref state);
                
            _completeQuery = new EntityQueryBuilder(Allocator.Temp)
                .WithAll<WorldBootstrapCompleteTag>()
                .Build(ref state);

            state.RequireForUpdate(_bootstrapQuery);
        }

        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            // Skip if bootstrap is already complete
            if (!_completeQuery.IsEmptyIgnoreFilter)
                return;

            // Skip if bootstrap is already in progress
            if (!_inProgressQuery.IsEmptyIgnoreFilter)
                return;

            // Get the bootstrap configuration
            var bootstrapEntity = _bootstrapQuery.GetSingletonEntity();
            var config = _bootstrapQuery.GetSingleton<WorldBootstrapConfiguration>();

            // Mark bootstrap as in progress
            state.EntityManager.AddComponentData(bootstrapEntity, new WorldBootstrapInProgressTag());

            // Generate the world hierarchy
            GenerateWorldHierarchy(ref state, config);

            // Mark bootstrap as complete
            state.EntityManager.RemoveComponent<WorldBootstrapInProgressTag>(bootstrapEntity);
            var completeTag = new WorldBootstrapCompleteTag(
                biomes: CalculateGeneratedBiomes(config),
                districts: CalculateGeneratedDistricts(config),
                sectors: CalculateGeneratedSectors(config),
                rooms: CalculateGeneratedRooms(config)
            );
            state.EntityManager.AddComponentData(bootstrapEntity, completeTag);

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (config.LogGenerationSteps)
            {
                UnityEngine.Debug.Log($"üöÄ WorldBootstrap: Generated {completeTag.DistrictsGenerated} districts, " +
                                    $"{completeTag.SectorsGenerated} sectors, {completeTag.RoomsGenerated} rooms");
            }
#endif
        }

        private static void GenerateWorldHierarchy(ref SystemState state, WorldBootstrapConfiguration config)
        {
            // Use seed or generate random one
            uint actualSeed = config.Seed == 0 ? (uint)(state.WorldUnmanaged.Time.ElapsedTime * 1000 + 1) : (uint)config.Seed;
            var random = new Unity.Mathematics.Random(actualSeed);

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (config.LogGenerationSteps)
            {
                UnityEngine.Debug.Log($"üåç WorldBootstrap: Starting generation with seed {actualSeed}");
            }
#endif

            // Step 1: Generate biome fields
            GenerateBiomeFields(ref state, config, ref random);

            // Step 2: Generate districts
            GenerateDistricts(ref state, config, ref random);

            // Note: Sectors and Rooms will be generated by the existing SectorRoomHierarchySystem
            // once the DistrictLayoutSystem places the districts we just created
        }

        private static void GenerateBiomeFields(ref SystemState state, WorldBootstrapConfiguration config, ref Unity.Mathematics.Random random)
        {
            int biomeCount = random.NextInt(config.BiomeCountRange.x, config.BiomeCountRange.y + 1);
            
            var biomeTypes = new NativeArray<BiomeType>(biomeCount, Allocator.Temp);
            var biomePositions = new NativeArray<float2>(biomeCount, Allocator.Temp);

            try
            {
                // Generate diverse biome types
                GenerateBiomeTypes(biomeTypes, ref random);
                
                // Generate biome positions using Poisson disc sampling
                GenerateBiomePositions(biomePositions, config.WorldSize, ref random);

                // Create biome field entities
                for (int i = 0; i < biomeCount; i++)
                {
                    CreateBiomeFieldEntity(ref state, biomeTypes[i], biomePositions[i], config, ref random);
                }

#if UNITY_EDITOR || DEVELOPMENT_BUILD
                if (config.LogGenerationSteps)
                {
                    UnityEngine.Debug.Log($"üåø WorldBootstrap: Generated {biomeCount} biome fields");
                }
#endif
            }
            finally
            {
                if (biomeTypes.IsCreated) biomeTypes.Dispose();
                if (biomePositions.IsCreated) biomePositions.Dispose();
            }
        }

        private static void GenerateDistricts(ref SystemState state, WorldBootstrapConfiguration config, ref Unity.Mathematics.Random random)
        {
            int districtCount = random.NextInt(config.DistrictCountRange.x, config.DistrictCountRange.y + 1);
            
            // Create districts at (0,0) coordinates - DistrictLayoutSystem will place them procedurally
            for (int i = 0; i < districtCount; i++)
            {
                CreateDistrictEntity(ref state, (uint)(i + 1), config, ref random);
            }

#if UNITY_EDITOR || DEVELOPMENT_BUILD
            if (config.LogGenerationSteps)
            {
                UnityEngine.Debug.Log($"üè∞ WorldBootstrap: Generated {districtCount} districts for procedural placement");
            }
#endif
        }

        private static void GenerateBiomeTypes(NativeArray<BiomeType> biomeTypes, ref Unity.Mathematics.Random random)
        {
            // Available biome types (excluding Unknown)
            var availableTypes = new NativeArray<BiomeType>(6, Allocator.Temp);
            availableTypes[0] = BiomeType.SolarPlains;
            availableTypes[1] = BiomeType.CrystalCaverns;
            availableTypes[2] = BiomeType.ShadowRealms;
            availableTypes[3] = BiomeType.VolcanicCore;
            availableTypes[4] = BiomeType.FrozenWastes;
            availableTypes[5] = BiomeType.HubArea;

            try
            {
                // Shuffle and select
                for (int i = availableTypes.Length - 1; i > 0; i--)
                {
                    int j = random.NextInt(0, i + 1);
                    (availableTypes[i], availableTypes[j]) = (availableTypes[j], availableTypes[i]);
                }

                for (int i = 0; i < biomeTypes.Length; i++)
                {
                    biomeTypes[i] = availableTypes[i % availableTypes.Length];
                }
            }
            finally
            {
                if (availableTypes.IsCreated) availableTypes.Dispose();
            }
        }

        private static void GenerateBiomePositions(NativeArray<float2> positions, int2 worldSize, ref Unity.Mathematics.Random random)
        {
            float minDistance = math.min(worldSize.x, worldSize.y) * 0.3f;
            int maxAttempts = 30;

            for (int i = 0; i < positions.Length; i++)
            {
                bool validPosition = false;
                int attempts = 0;

                while (!validPosition && attempts < maxAttempts)
                {
                    float2 candidate = new float2(
                        random.NextFloat(-worldSize.x * 0.4f, worldSize.x * 0.4f),
                        random.NextFloat(-worldSize.y * 0.4f, worldSize.y * 0.4f)
                    );

                    validPosition = true;
                    for (int j = 0; j < i; j++)
                    {
                        if (math.length(candidate - positions[j]) < minDistance)
                        {
                            validPosition = false;
                            break;
                        }
                    }

                    if (validPosition)
                        positions[i] = candidate;

                    attempts++;
                }

                if (!validPosition)
                {
                    // Fallback to random position
                    positions[i] = new float2(
                        random.NextFloat(-worldSize.x * 0.4f, worldSize.x * 0.4f),
                        random.NextFloat(-worldSize.y * 0.4f, worldSize.y * 0.4f)
                    );
                }
            }
        }

        private static void CreateBiomeFieldEntity(ref SystemState state, BiomeType biomeType, float2 position, 
                                                 WorldBootstrapConfiguration config, ref Unity.Mathematics.Random random)
        {
            var entity = state.EntityManager.CreateEntity();
            
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            state.EntityManager.SetName(entity, $"BiomeField_{biomeType}");
#endif

            // TODO: Implement the full biome field system.
            // Intended future behavior:
            // - Support multiple biomes per field with weighted strengths.
            // - Allow for dynamic blending and transitions between biomes.
            // - Store additional biome metadata (e.g., temperature, humidity, special features).
            // - Integrate with world generation and district/sector placement logic.
            // - Provide editor/debug visualization for biome fields.
            // Current implementation: simple biome field marker for prototyping.
            state.EntityManager.AddComponentData(entity, new BiomeFieldData
            {
                PrimaryBiome = biomeType,
                SecondaryBiome = BiomeType.Unknown,
                Strength = 1.0f,
                Gradient = random.NextFloat(0.3f, 0.8f)
            });
        }

        private static void CreateDistrictEntity(ref SystemState state, uint nodeId, 
                                               WorldBootstrapConfiguration config, ref Unity.Mathematics.Random random)
        {
            var entity = state.EntityManager.CreateEntity();
            
#if UNITY_EDITOR || DEVELOPMENT_BUILD
            state.EntityManager.SetName(entity, $"District_{nodeId}");
#endif

            // Create district at (0,0) - DistrictLayoutSystem will place it
            state.EntityManager.AddComponentData(entity, new NodeId(nodeId, 0, 0, int2.zero));
            state.EntityManager.AddComponentData(entity, new WfcState(WfcGenerationState.Initialized));
            state.EntityManager.AddComponentData(entity, new SectorRefinementData(config.TargetLoopDensity));

            // Add sector hierarchy data for the SectorRoomHierarchySystem
            int sectorCount = random.NextInt(config.SectorsPerDistrictRange.x, config.SectorsPerDistrictRange.y + 1);
            state.EntityManager.AddComponentData(entity, new SectorHierarchyData(
                config.SectorGridSize, 
                sectorCount, 
                random.NextUInt()
            ));

            // Add required buffers
            state.EntityManager.AddBuffer<ConnectionBufferElement>(entity);
            state.EntityManager.AddBuffer<GateConditionBufferElement>(entity);
        }

        private static int CalculateGeneratedBiomes(WorldBootstrapConfiguration config)
        {
            return (config.BiomeCountRange.x + config.BiomeCountRange.y) / 2;
        }

        private static int CalculateGeneratedDistricts(WorldBootstrapConfiguration config)
        {
            return (config.DistrictCountRange.x + config.DistrictCountRange.y) / 2;
        }

        private static int CalculateGeneratedSectors(WorldBootstrapConfiguration config)
        {
            int avgDistricts = CalculateGeneratedDistricts(config);
            int avgSectorsPerDistrict = (config.SectorsPerDistrictRange.x + config.SectorsPerDistrictRange.y) / 2;
            return avgDistricts * avgSectorsPerDistrict;
        }

        private static int CalculateGeneratedRooms(WorldBootstrapConfiguration config)
        {
            int avgSectors = CalculateGeneratedSectors(config);
            int avgRoomsPerSector = (config.RoomsPerSectorRange.x + config.RoomsPerSectorRange.y) / 2;
            return avgSectors * avgRoomsPerSector;
        }
    }
}